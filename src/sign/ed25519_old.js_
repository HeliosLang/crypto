import { sha2_512 } from "../digest/index.js"
import {
    ED25519_CURVE_ORDER,
    decodeCurveInt,
    encodeCurveInt,
    posMod
} from "./CurvePoint.js"
import { ExtendedPoint } from "./ed25517/ExtendedPoint.js"

/**
 * @template {CurvePoint<T>} T
 * @typedef {import("./CurvePoint.js").CurvePoint<T>} CurvePoint
 */

/**
 * @template {CurvePoint<T>} T
 * @typedef {import("./CurvePoint.js").CurvePointClass<T>} CurvePointClass
 */

/**
 * The elliptic curve signature algorithm used by Cardano wallets.
 *
 * Ported from: [https://ed25519.cr.yp.to/python/ed25519.py](https://ed25519.cr.yp.to/python/ed25519.py).
 */

/**
 * @type {CurvePointClass<ExtendedPoint>}
 */
const CurvePointImpl = ExtendedPoint

/**
 * @param {number[]} m
 * @returns {bigint}
 */
function nonce(m) {
    return decodeCurveInt(sha2_512(m))
}

/**
 * Similar to `Ed25519.derivePublicKey`, but doesn't hash the input key.
 * @param {number[]} extendedKey
 * @returns {number[]} 32 byte public key.
 */
export function deriveBip32PublicKey(extendedKey) {
    const x = decodeCurveInt(extendedKey, true)
    const h = CurvePointImpl.BASE.mul(x)

    return h.encode()
}

/**
 * Derive a public key from a private key.
 * The private key can be any number of bytes (it's hashed internally).
 * The returned public key is 32 bytes long.
 * @param {number[]} privateKey
 * @returns {number[]} 32 byte public key.
 */
export function deriveEd25519PublicKey(privateKey) {
    return deriveBip32PublicKey(sha2_512(privateKey))
}

/**
 * Like `Ed25519.sign`, but doesn't hash the input key.
 * @param {number[]} message
 * @param {number[]} extendedKey
 * @returns {number[]} 64 byte signature.
 */
export function signBip32(message, extendedKey) {
    // extract privateKey as integer
    const x = decodeCurveInt(extendedKey, true)

    // for convenience calculate publicKey here:
    const publicKey = CurvePointImpl.BASE.mul(x).encode()

    // generate a practically random number
    const k = nonce(extendedKey.slice(32, 64).concat(message))

    // first part of the signature
    const a = CurvePointImpl.BASE.mul(k)
    const aEncoded = a.encode()

    // second part of the signature
    const bijectedMessage = nonce(aEncoded.concat(publicKey).concat(message))
    const b = CurvePointImpl.mod(k + bijectedMessage * x)
    const bEncoded = encodeCurveInt(b)

    return aEncoded.concat(bEncoded)
}

/**
 * Creates a 64 byte signature.
 * @param {number[]} message
 * @param {number[]} privateKey
 * @returns {number[]} 64 byte signature.
 */
function signEd25519(message, privateKey) {
    return signBip32(message, sha2_512(privateKey))
}

/**
 * Returns `true` if the signature is correct.
 * @param {number[]} signature
 * @param {number[]} message
 * @param {number[]} publicKey
 * @returns {boolean}
 */
export function verifyEd25519Signature(signature, message, publicKey) {
    if (signature.length != 64) {
        throw new Error(`unexpected signature length ${signature.length}`)
    }

    if (publicKey.length != 32) {
        throw new Error(`unexpected publickey length ${publicKey.length}`)
    }

    const a = CurvePointImpl.decode(signature.slice(0, 32))
    const h = CurvePointImpl.decode(publicKey)
    const b = decodeCurveInt(signature.slice(32, 64))
    const bijectedMessage = nonce(
        signature.slice(0, 32).concat(publicKey).concat(message)
    )

    const left = CurvePointImpl.BASE.mul(b)
    const right = a.add(h.mul(bijectedMessage))

    return left.equals(right)
}

const Ed25519 = {}
